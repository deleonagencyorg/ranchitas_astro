---
import CategoryCard from './CategoryCard.astro';

export interface Props {
  categories: any[];
  title?: string;
  subtitle?: string;
  disableLinks?: boolean;
}

const {
  categories = [],
  title,
  subtitle,
  disableLinks = false
} = Astro.props;

const categoryItems = Array.isArray(categories) ? categories : [];

const hasNoCategories = categoryItems.length === 0;
const carouselCategories = hasNoCategories
  ? [
      {
        id: 'placeholder',
        title: '',
        description: '',
        image: '/images/es/placeholder.jpg',
        gradient: 'from-gray-200 to-gray-300',
        url: '#'
      }
    ]
  : categoryItems;

// Helper to get a consistent key for category types if needed in the future
function getCategoryType(category: any): string {
  return String(category?.id || 'general').trim().toLowerCase();
}
---

<div class="w-full" data-categories-carousel>
  <div class="w-full px-0 md:px-4">
    <!-- Title Section -->
 
    <!-- Desktop Carousel -->
    <div class="categories-carousel relative">
      <div class="categories-carousel-container overflow-hidden px-4 md:px-0">
        <div class="categories-carousel-track flex items-start gap-4 md:gap-6 transition-transform duration-300" id="categoriesTrackDesktop" style="transform: translateX(0px); width: max-content;">
          {carouselCategories.map((category, index) => (
            <div class="category-slide flex-shrink-0 w-[calc(100vw-2rem)] md:w-auto" data-index={index} data-category={getCategoryType(category)}>
              <CategoryCard
                id={category.id}
                title={category.title}
                description={category.description}
                image={category.image}
                gradient={category.gradient}
                url={category.url}
                clickable={!disableLinks && !hasNoCategories}
              />
            </div>
          ))}
        </div>
      </div>

      <!-- Desktop Navigation Controls -->
      <div class="flex justify-center items-center gap-4 mt-8">
        <button class="carousel-prev bg-white text-pink p-2 rounded-full shadow-lg z-10" aria-label="Anterior" id="prevBtnDesktop">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
          </svg>
        </button>
        <div class="carousel-dots-desktop flex gap-2"></div>
        <button class="carousel-next bg-white text-pink p-2 rounded-full shadow-lg z-10" aria-label="Siguiente" id="nextBtnDesktop">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
          </svg>
        </button>
      </div>
    </div>
  </div>
</div>

<script>
  function initCategoriesCarousel(root: HTMLElement) {
    if (!root || root.dataset.ccInitialized === 'true') return;
    root.dataset.ccInitialized = 'true';

    setupDesktopCarousel();

    function setupDesktopCarousel() {
      const track = root.querySelector('#categoriesTrackDesktop') as HTMLElement | null;
      const prevBtn = root.querySelector('#prevBtnDesktop') as HTMLElement | null;
      const nextBtn = root.querySelector('#nextBtnDesktop') as HTMLElement | null;
      const dotsContainer = root.querySelector('.carousel-dots-desktop') as HTMLElement | null;

      if (!track || !prevBtn || !nextBtn || !dotsContainer) return;

      const slides = Array.from(track.querySelectorAll('.category-slide')) as HTMLElement[];
      // Inicializar en 0 para mostrar la primera categoría
      let currentSlide = 0;
      
      // Responsive slidesPerView: 1 en mobile, 4 en desktop
      function getSlidesPerView() {
        return window.innerWidth < 768 ? 1 : 4;
      }
      
      let slidesPerView = getSlidesPerView();
      
      // Asegurar que el track esté visible desde el inicio
      track.style.transform = 'translateX(0px)';
      
      // Asegurar que el contenedor tenga el ancho correcto
      track.style.width = 'max-content';

      if (slides.length <= slidesPerView) {
        prevBtn.style.display = 'none';
        nextBtn.style.display = 'none';
        dotsContainer.style.display = 'none';
        // Center the items if they are less than the view
        track.parentElement.style.display = 'flex';
        track.parentElement.style.justifyContent = 'center';
        return;
      }

      const prevClone = prevBtn.cloneNode(true);
      const nextClone = nextBtn.cloneNode(true);
      prevBtn.parentNode.replaceChild(prevClone, prevBtn);
      nextBtn.parentNode.replaceChild(nextClone, nextBtn);

      const prevButton = prevClone as HTMLButtonElement;
      const nextButton = nextClone as HTMLButtonElement;

      // Llamar a createDots primero para que los puntos estén listos
      createDots();
      
      // Luego actualizar el carrusel para mostrar la primera categoría
      updateCarousel();
      
      // Forzar la visibilidad de la primera categoría
      setTimeout(() => {
        currentSlide = 0;
        track.style.transform = 'translateX(0px)';
        updateDots();
        updateButtons();
      }, 100);

      prevButton.addEventListener('click', () => {
        if (currentSlide > 0) {
          currentSlide--;
          updateCarousel();
        }
      });

      nextButton.addEventListener('click', () => {
        if (currentSlide < slides.length - slidesPerView) {
          currentSlide++;
          updateCarousel();
        }
      });

      function createDots() {
        dotsContainer.innerHTML = '';
        slidesPerView = getSlidesPerView();
        const totalDots = Math.max(0, slides.length - slidesPerView + 1);
        for (let i = 0; i < totalDots; i++) {
          const dot = document.createElement('button');
          dot.classList.add('w-3', 'h-3', 'rounded-full', i === currentSlide ? 'bg-white' : 'bg-gray-100');
          dot.addEventListener('click', () => {
            currentSlide = i;
            updateCarousel();
          });
          dotsContainer.appendChild(dot);
        }
      }

      function updateCarousel() {
        // Asegurar que el carrusel comience desde la primera categoría
        slidesPerView = getSlidesPerView();
        
        // Calcular offset basado en el ancho de la pantalla
        // Mobile: usar el ancho de la primera slide + gap
        // Desktop: usar el ancho fijo de la card (310px) + gap (24px)
        let offset;
        if (window.innerWidth < 768) {
          const firstSlide = slides[0];
          const slideWidth = firstSlide ? firstSlide.offsetWidth : window.innerWidth - 32;
          const gap = 16; // gap-4 = 1rem = 16px
          offset = currentSlide * (slideWidth + gap);
        } else {
          offset = currentSlide * (310 + 24); // 310px card width + 24px gap
        }
        
        track.style.transform = `translateX(-${offset}px)`;

        slides.forEach((slideEl: HTMLElement) => {
            const card = slideEl.querySelector('a');
            if (!card) return;

            // Clone to remove old listeners
            const newCard = card.cloneNode(true);
            card.parentNode.replaceChild(newCard, card);

            const slideContainer = newCard.parentElement as HTMLElement;
            const cardContainer = newCard.querySelector('div');
            const gradientBg = cardContainer.querySelector('div:first-child');
            const contentBg = cardContainer.querySelector('div:last-child');

            const originalWidth = 310;
            const expandedWidth = 380;

            // Set base transition
            slideContainer.style.transition = 'width 300ms ease';
            newCard.style.transition = 'opacity 300ms ease';
            [cardContainer, gradientBg, contentBg].forEach(el => {
                if(el) el.style.transition = 'width 300ms ease';
            });

            newCard.addEventListener('mouseenter', () => {
                if (window.innerWidth < 768) return;

                slideContainer.style.width = `${expandedWidth}px`;
                if(cardContainer) cardContainer.style.width = `${expandedWidth}px`;
                if(gradientBg) gradientBg.style.width = `${expandedWidth}px`;
                if(contentBg) contentBg.style.width = `${expandedWidth}px`;

                slides.forEach((s: HTMLElement) => {
                    const otherCard = s.querySelector('a') as HTMLElement | null;
                    if (otherCard !== newCard) {
                        otherCard.style.opacity = '0.6';
                    }
                });
            });

            newCard.addEventListener('mouseleave', () => {
                if (window.innerWidth < 768) return;

                slideContainer.style.width = `${originalWidth}px`;
                if(cardContainer) cardContainer.style.width = `${originalWidth}px`;
                if(gradientBg) gradientBg.style.width = `${originalWidth}px`;
                if(contentBg) contentBg.style.width = `${originalWidth}px`;

                slides.forEach((s: HTMLElement) => {
                    const anchor = s.querySelector('a') as HTMLElement | null;
                    if (anchor) anchor.style.opacity = '1';
                });
            });
        });

        updateDots();
        updateButtons();
      }

      function updateDots() {
        const dots = dotsContainer.querySelectorAll<HTMLButtonElement>('button');
        dots.forEach((dot: HTMLButtonElement, i: number) => {
          dot.classList.toggle('bg-brown', i === currentSlide);
          dot.classList.toggle('bg-gray-300', i !== currentSlide);
        });
      }

      function updateButtons() {
        slidesPerView = getSlidesPerView();
        prevButton.disabled = currentSlide === 0;
        nextButton.disabled = currentSlide >= slides.length - slidesPerView;
        prevButton.classList.toggle('opacity-50', prevButton.disabled);
        nextButton.classList.toggle('opacity-50', nextButton.disabled);
      }
      
      // Agregar listener para resize para actualizar el carousel cuando cambie el tamaño de la ventana
      let resizeTimeout: number;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          const newSlidesPerView = getSlidesPerView();
          if (newSlidesPerView !== slidesPerView) {
            // Resetear a la primera slide si cambia el modo
            currentSlide = 0;
            createDots();
            updateCarousel();
          }
        }, 150);
      });
    }
  }

  function initAll() {
    document.querySelectorAll('[data-categories-carousel]').forEach(initCategoriesCarousel);
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initAll);
  } else {
    initAll();
  }
  document.addEventListener('astro:page-load', initAll);
  document.addEventListener('astro:after-swap', initAll);
</script>
